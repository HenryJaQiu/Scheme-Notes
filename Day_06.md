我们通常使用计算阶乘来解释递归。

```scheme
(define (fact n)
  (if (= n 1)
      1
      (* n (fact (- n 1)))))
```

然而，递归函数可以以一种简单的方式表达重复。表是被递归定义的，进而表和递归函数可以很好地配合。例如，一个让表中所有元素翻倍的函数可以像下面这样写。如果参数是空表，那么函数应该停止计算并返回一个空表。

```scheme
(define (list*2 ls)
  (if (null? ls)
      '()
      (cons (* 2 (car ls))
             (list*2 (cdr ls)))))
```

普通的递归调用并不高效因为它既浪费存储空间又具有函数调用开销。与之相反，尾递归函数包含了计算结果，当计算结束时直接将其返回。特别地，由于Scheme规范要求尾递归调用转化为循环，因此尾递归调用就不存在函数调用开销。

[代码片段2]展示了[代码片段1]中函数`fact`的尾递归版本。

```scheme
(define (fact-tail n)
  (fact-rec n n))

(define (fact-rec n p)
  (if (= n 1)
      p
      (let ((m (- n 1)))
    (fact-rec m (* p m)))))
```

因为`fact-rec`并不等待其它函数的计算结果，因此当它计算结束时即从内存中释放。计算通过修改`fact-rec`的参数来演进，这基本上等同于循环。如上文所述，Scheme将尾递归转化为循环，Scheme就无需提供循环的语法来实现重复。

命名`let`（**named let**）可以用来表达循环。[代码片段3]中的函数`fact-let`展示了如何使用命名`let`来计算阶乘。`fact-let`函数使用了一个**命名let表达式**`(loop)`，这与在[代码片段2]中展示的`fact-rec`函数是不同的。在被注释为`;1`的那行，代码将参数`n1`和`p`都初始化为`n`。再每次循环后，参数在被注释为`;2`的那行更新：将`n1`减1，而将`p`乘以`(n1 - 1)`。

在Scheme中，用命名`let`来表达循环是俗成的方法。

```scheme
(define (fact-let n)
  (let loop((n1 n) (p n))           ; 1
    (if (= n1 1)                    
    p
    (let ((m (- n1 1)))
      (loop m (* p m))))))      ; 2
```

`letrec`类似于`let`，但它允许一个名字递归地调用它自己。语法`letrec`通常用于定义复杂的递归函数。

[代码片段4]展示了`fact`函数的`letrec`版本。

```scheme
(define (fact-letrec n)
  (letrec ((iter (lambda (n1 p)
           (if (= n1 1)
               p
               (let ((m (- n1 1)))
             (iter m (* p m)))))))     ; *
    (iter n n)))
```

正如被注释为`;*`的那行代码所示，局部变量`iter`可以在它的定义里面引用它自己。语法`letrec`是定义局部变量的俗成方式。

虽然并不常见，但语法`do`也可用于表达重复。它的格式如下：

```scheme
(do binds (predicate value)
    body)
```

变量在`binds`部分被绑定，而如果`predicate`被求值为真，则函数从循环中**逃逸（escape）**出来，并返回值`value`，否则循环继续进行。

`binds`部分的格式如下所示：

```
[binds] → ((p1 i1 u1) (p2 i2 u2) ... )
```

变量`p1`，`p2`，...被分别初始化为`i1`，`i2`，...并在循环后分别被更新为`u1`，`u2`，...。

[代码片段5]演示了`fact`的`do`表达式版本。

```scheme
(define (fact-do n)
  (do ((n1 n (- n1 1)) (p n (* p (- n1 1)))) ((= n1 1) p)))
```

变量`n1`和`p`分别被初始化为`n`和`n`，在每次循环后分别被减去1和乘以`(n1 - 1)`。当`n1`变为`1`时，函数返回`p`。

我认为`do`比命名`let`还要复杂一些。
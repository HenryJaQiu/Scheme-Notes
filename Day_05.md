使用`let`表达式可以定义局部变量。格式如下：

```scheme
(let binds body)
```

变量在`binds`定义的形式中被声明并初始化。`body`由任意多个S-表达式构成。`binds`的格式如下：

```
[binds] → ((p1 v1) (p2 v2) ...)
```

声明了变量`p1`、`p2`，并分别为它们赋初值`v1`、`v2`。变量的**作用域（Scope）**为`body`体，也就是说变量只在`body`中有效。

> 例1：声明局部变量`i`和`j`，将它们与`1`、`2`绑定，然后求二者的和。

```scheme
(let ((i 1) (j 2))
  (+ i j))
;Value: 3
```

`let`表达式可以嵌套使用。

> 例2：声明局部变量`i`和`j`，并将分别将它们与`1`和`i+2`绑定，然后求它们的乘积。

```scheme
(let ((i 1))
  (let ((j (+ i 2)))
    (* i j)))
;Value: 3
```

由于变量的作用域仅在`body`中，下列代码会产生错误，因为在变量`j`的作用域中没有变量`i`的定义。

```scheme
(let ((i 1) (j (+ i 2)))
  (* i j))
;Error
```

`let*`表达式可以用于引用定义在同一个绑定中的变量。实际上，`let*`只是嵌套的`let`表达式的语法糖而已。

```scheme
(let* ((i 1) (j (+ i 2)))
  (* i j))
;Value: 3
```
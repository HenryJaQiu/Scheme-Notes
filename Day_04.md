`if`表达式将过程分为两个部分。`if`的格式如下：

```scheme
(if predicate then_value else_value)
```

如果`predicate`部分为真，那么`then_value`部分被求值，否则`else_value`部分被求值，并且求得的值会返回给`if`语句的括号外。`true`是除`false`以外的任意值，`true`使用`#t`表示，`false`用`#f`表示。

在R5RS中，`false`（`#f`）和空表`（’()）`是两个不同的对象。然而，在MIT-Scheme中，这两个为同一对象。这个不同可能是历史遗留问题，在以前的标准——R4RS中，`#f`和`’()`被定义为同一对象。

因此，从兼容性角度考虑，你不应该使用表目录作为谓词。使用函数`null?`来判断表是否为空。



`and`和`or`是用于组合条件的两个特殊形式。Scheme中的`and`和`or`不同于C语言中的约定。它们不返回一个布尔值（`#t`或`#f`），而是返回给定的参数之一。`and`和`or`可以使你的代码更加短小。

`and`具有任意个数的参数，并从左到右对它们求值。如果某一参数为`#f`，那么它就返回`#f`，而不对剩余参数求值。反过来说，如果所有的参数都不是`#f`，那么就返回最后一个参数的值。

`or`具有可变个数的参数，并从左到右对它们求值。它返回第一个不是值`#f`的参数，而余下的参数不会被求值。如果所有的参数的值都是`#f`的话，则返回最后一个参数的值。

尽管所有的分支都可以用`if`表达式表达，但当条件有更多的可能性时，你就需要使用嵌套的`if`表达式了，这将使代码变得复杂。处理这种情况可以使用`cond`表达式。`cond`表达式的格式如下：

```scheme
(cond
  (predicate_1 clauses_1)
  (predicate_2 clauses_2)
    ......
  (predicate_n clauses_n)
  (else        clauses_else))
```

在`cond`表达式中，`predicates_i`是按照从上到下的顺序求值，而当`predicates_i`为真时，`clause_i`会被求值并返回。`i`之后的`predicates`和`clauses`不会被求值。如果所有的`predicates_i`都是假的话，则返回`cluase_else`。在一个子句中，你可以写数条S-表达式，而`clause`的值是最后一条S-表达式。

`eq?`
该函数比较两个对象的地址，如果相同的话就返回`#t`。例如，`(eq? str str)`返回`#t`，因为`str`本身的地址是一致的。与此相对的，因为字符串`”hello”`和`”hello”`被储存在了不同的地址中，函数将返回`#f`。不要使用`eq?`来比较数字，因为不仅在R5RS中，甚至在MIT-Scheme实现中，它都没有指定返回值。使用`eqv?`或者`=`替代。

`eqv?`
该函数比较两个存储在内存中的对象的类型和值。如果类型和值都一致的话就返回`#t`。对于过程（`lambda`表达式）的比较依赖于具体的实现。这个函数不能用于类似于表和字符串一类的序列比较，因为尽管这些序列看起来是一致的，但它们的值是存储在不同的地址中。

`equal?`
该函数用于比较类似于表或者字符串一类的序列。

- `pair?` 如果对象为序对则返回`#t`；
- `list?` 如果对象是一个表则返回`#t`。要小心的是空表`’()`是一个表但是不是一个序对。
- `null?` 如果对象是空表’()的话就返回#t。
- `symbol?` 如果对象是一个符号则返回#t。
- `char?` 如果对象是一个字符则返回#t。
- `string?` 如果对象是一个字符串则返回#t。
- `number?` 如果对象是一个数字则返回#t。
- `complex?` 如果对象是一个复数则返回#t。
- `real?` 如果对象是一个实数则返回#t。
- `rational?` 如果对象是一个有理数则返回#t。
- `integer?` 如果对象是一个整数则返回#t。
- `exact?` 如果对象不是一个浮点数的话则返回#t。
- `inexact?` 如果对象是一个浮点数的话则返回#t。



`=`、`>`、`<`、`<=`、`>=`
这些函数都有任意个数的参数。如果参数是按照这些函数的名字排序的话，函数就返回`#t`。

`odd?`、`even?`、`positive?`、`negative?`、`zero?`
这些函数仅有一个参数，如果这些参数满足函数名所指示的条件话就返回`#t`。